import type { AbortSignal, ReadableWritablePair, WritableStreamDefaultWriter } from "@yume-chan/stream-extra";
import type { AsyncExactReadable, ExactReadable, ValueOrPromise } from "@yume-chan/struct";
import type { AdbIncomingSocketHandler, AdbSocket, Closeable } from "../adb.js";
import type { AdbFeature } from "../features.js";
import { AdbServerTransport } from "./transport.js";
export interface AdbServerConnectionOptions {
    unref?: boolean | undefined;
    signal?: AbortSignal | undefined;
}
export interface AdbServerConnection extends ReadableWritablePair<Uint8Array, Uint8Array>, Closeable {
    get closed(): Promise<void>;
}
export interface AdbServerConnector {
    connect(options?: AdbServerConnectionOptions): ValueOrPromise<AdbServerConnection>;
    addReverseTunnel(handler: AdbIncomingSocketHandler, address?: string): ValueOrPromise<string>;
    removeReverseTunnel(address: string): ValueOrPromise<void>;
    clearReverseTunnels(): ValueOrPromise<void>;
}
export interface AdbServerSocket extends AdbSocket {
    transportId: bigint;
}
export type AdbServerDeviceSelector = {
    transportId: bigint;
} | {
    serial: string;
} | {
    usb: true;
} | {
    tcp: true;
} | undefined;
export interface AdbServerDevice {
    serial: string;
    product?: string | undefined;
    model?: string | undefined;
    device?: string | undefined;
    transportId: bigint;
}
export declare class AdbServerClient {
    static readonly VERSION = 41;
    readonly connection: AdbServerConnector;
    constructor(connection: AdbServerConnector);
    static readString(stream: ExactReadable): string;
    static readString(stream: AsyncExactReadable): PromiseLike<string>;
    static writeString(writer: WritableStreamDefaultWriter<Uint8Array>, value: string): Promise<void>;
    static readOkay(stream: ExactReadable | AsyncExactReadable): Promise<void>;
    connect(request: string, options?: AdbServerConnectionOptions): Promise<AdbServerConnection>;
    getVersion(): Promise<number>;
    validateVersion(): Promise<void>;
    killServer(): Promise<void>;
    getServerFeatures(): Promise<AdbFeature[]>;
    parseDeviceList(value: string): AdbServerDevice[];
    getDevices(): Promise<AdbServerDevice[]>;
    trackDevices(callback: (devices: AdbServerDevice[]) => void): Promise<() => void>;
    formatDeviceService(device: AdbServerDeviceSelector, command: string): string;
    /**
     * Gets the features supported by the device.
     * The transport ID of the selected device is also returned,
     * so the caller can execute other commands against the same device.
     * @param device The device selector
     * @returns The transport ID of the selected device, and the features supported by the device.
     */
    getDeviceFeatures(device: AdbServerDeviceSelector): Promise<{
        transportId: bigint;
        features: AdbFeature[];
    }>;
    /**
     * Creates a connection that will forward the service to device.
     * @param device The device selector
     * @param service The service to forward
     * @returns An `AdbServerSocket` that can be used to communicate with the service
     */
    connectDevice(device: AdbServerDeviceSelector, service: string): Promise<AdbServerSocket>;
    /**
     * Wait for a device to be connected or disconnected.
     * @param device The device selector
     * @param state The state to wait for
     * @param options The options
     * @returns A promise that resolves when the condition is met.
     */
    waitFor(device: AdbServerDeviceSelector, state: "device" | "disconnect", options?: AdbServerConnectionOptions): Promise<void>;
    createTransport(device: AdbServerDeviceSelector): Promise<AdbServerTransport>;
}
export declare function raceSignal<T>(callback: () => Promise<T>, ...signals: (AbortSignal | undefined)[]): Promise<T>;
//# sourceMappingURL=client.d.ts.map