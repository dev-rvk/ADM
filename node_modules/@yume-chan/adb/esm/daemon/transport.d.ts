import type { Consumable, ReadableWritablePair } from "@yume-chan/stream-extra";
import type { ValueOrPromise } from "@yume-chan/struct";
import type { AdbIncomingSocketHandler, AdbSocket, AdbTransport } from "../adb.js";
import { AdbBanner } from "../banner.js";
import { AdbFeature } from "../features.js";
import type { AdbAuthenticator, AdbCredentialStore } from "./auth.js";
import type { AdbPacketData, AdbPacketInit } from "./packet.js";
export declare const ADB_DAEMON_VERSION_OMIT_CHECKSUM = 16777217;
export declare const ADB_DAEMON_DEFAULT_FEATURES: AdbFeature[];
export declare const ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE: number;
export type AdbDaemonConnection = ReadableWritablePair<AdbPacketData, Consumable<AdbPacketInit>>;
interface AdbDaemonAuthenticationOptions {
    serial: string;
    connection: AdbDaemonConnection;
    credentialStore: AdbCredentialStore;
    authenticators?: AdbAuthenticator[];
    features?: readonly AdbFeature[];
    /**
     * The number of bytes the device can send before receiving an ack packet.
     *
     * Set to 0 or any negative value to disable delayed ack in handshake.
     * Otherwise the value must be in the range of unsigned 32-bit integer.
     *
     * Delayed ack requires Android 14, this option is ignored on older versions.
     */
    initialDelayedAckBytes?: number;
    /**
     * Whether to preserve the connection open after the `AdbDaemonTransport` is closed.
     */
    preserveConnection?: boolean | undefined;
    debugSlowRead?: boolean | undefined;
}
interface AdbDaemonSocketConnectorConstructionOptions {
    serial: string;
    connection: AdbDaemonConnection;
    version: number;
    maxPayloadSize: number;
    banner: string;
    features?: readonly AdbFeature[];
    /**
     * The number of bytes the device can send before receiving an ack packet.
     *
     * Set to 0 or any negative value to disable delayed ack in handshake.
     * Otherwise the value must be in the range of unsigned 32-bit integer.
     *
     * Delayed ack requires Android 14, this option is ignored on older versions.
     */
    initialDelayedAckBytes?: number;
    /**
     * Whether to preserve the connection open after the `AdbDaemonTransport` is closed.
     */
    preserveConnection?: boolean | undefined;
    debugSlowRead?: boolean | undefined;
}
export declare class AdbDaemonTransport implements AdbTransport {
    #private;
    /**
     * Authenticates the connection and creates an `AdbDaemonTransport` instance
     * that can be used by `Adb` class.
     *
     * If an authentication process failed, it's possible to call `authenticate` again
     * on the same connection. Because every time the device receives a `CNXN` packet,
     * it resets all internal state, and starts a new authentication process.
     */
    static authenticate({ serial, connection, credentialStore, authenticators, features, initialDelayedAckBytes, ...options }: AdbDaemonAuthenticationOptions): Promise<AdbDaemonTransport>;
    get connection(): AdbDaemonConnection;
    get serial(): string;
    get protocolVersion(): number;
    get maxPayloadSize(): number;
    get banner(): AdbBanner;
    get disconnected(): Promise<void>;
    get clientFeatures(): readonly AdbFeature[];
    constructor({ serial, connection, version, banner, features, initialDelayedAckBytes, ...options }: AdbDaemonSocketConnectorConstructionOptions);
    connect(service: string): ValueOrPromise<AdbSocket>;
    addReverseTunnel(handler: AdbIncomingSocketHandler, address?: string): string;
    removeReverseTunnel(address: string): void;
    clearReverseTunnels(): void;
    close(): ValueOrPromise<void>;
}
export {};
//# sourceMappingURL=transport.d.ts.map