import { ConsumableWritableStream } from "@yume-chan/stream-extra";
import { ScrcpyControlMessageSerializer } from "./serializer.js";
export class ScrcpyControlMessageWriter {
    #writer;
    #serializer;
    constructor(writer, options) {
        this.#writer = writer;
        this.#serializer = new ScrcpyControlMessageSerializer(options);
    }
    async write(message) {
        await ConsumableWritableStream.write(this.#writer, message);
    }
    async injectKeyCode(message) {
        await this.write(this.#serializer.injectKeyCode(message));
    }
    async injectText(text) {
        await this.write(this.#serializer.injectText(text));
    }
    /**
     * `pressure` is a float value between 0 and 1.
     */
    async injectTouch(message) {
        await this.write(this.#serializer.injectTouch(message));
    }
    /**
     * `scrollX` and `scrollY` are float values between 0 and 1.
     */
    async injectScroll(message) {
        const data = this.#serializer.injectScroll(message);
        if (data) {
            await this.write(data);
        }
    }
    async backOrScreenOn(action) {
        const data = this.#serializer.backOrScreenOn(action);
        if (data) {
            await this.write(data);
        }
    }
    async setScreenPowerMode(mode) {
        await this.write(this.#serializer.setScreenPowerMode(mode));
    }
    async expandNotificationPanel() {
        await this.write(this.#serializer.expandNotificationPanel());
    }
    async expandSettingPanel() {
        await this.write(this.#serializer.expandSettingPanel());
    }
    async collapseNotificationPanel() {
        await this.write(this.#serializer.collapseNotificationPanel());
    }
    async rotateDevice() {
        await this.write(this.#serializer.rotateDevice());
    }
    releaseLock() {
        this.#writer.releaseLock();
    }
    async close() {
        await this.#writer.close();
    }
}
//# sourceMappingURL=writer.js.map