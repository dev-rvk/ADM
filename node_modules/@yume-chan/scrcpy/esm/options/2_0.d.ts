import type { ReadableStream } from "@yume-chan/stream-extra";
import type { ValueOrPromise } from "@yume-chan/struct";
import Struct from "@yume-chan/struct";
import type { AndroidMotionEventAction, ScrcpyInjectTouchControlMessage } from "../control/index.js";
import { CodecOptions } from "./1_16/index.js";
import type { ScrcpyOptionsInit1_24 } from "./1_24.js";
import { ScrcpyOptions1_25 } from "./1_25/index.js";
import type { ScrcpyAudioStreamMetadata, ScrcpyVideoStream } from "./codec.js";
import type { ScrcpyDisplay, ScrcpyEncoder, ScrcpyOptionValue } from "./types.js";
import { ScrcpyOptionsBase } from "./types.js";
export declare const ScrcpyInjectTouchControlMessage2_0: Struct<{
    type: number;
    action: AndroidMotionEventAction;
    pointerId: bigint;
    pointerX: number;
    pointerY: number;
    screenWidth: number;
    screenHeight: number;
    pressure: number;
    actionButton: number;
    buttons: number;
}, never, Record<never, never>, undefined>;
export type ScrcpyInjectTouchControlMessage2_0 = (typeof ScrcpyInjectTouchControlMessage2_0)["TInit"];
export declare class ScrcpyInstanceId implements ScrcpyOptionValue {
    static readonly NONE: ScrcpyInstanceId;
    static random(): ScrcpyInstanceId;
    value: number;
    constructor(value: number);
    toOptionValue(): string | undefined;
}
export interface ScrcpyOptionsInit2_0 extends Omit<ScrcpyOptionsInit1_24, "bitRate" | "codecOptions" | "encoderName"> {
    scid?: ScrcpyInstanceId;
    videoCodec?: "h264" | "h265" | "av1";
    videoBitRate?: number;
    videoCodecOptions?: CodecOptions;
    videoEncoder?: string;
    audio?: boolean;
    audioCodec?: "opus" | "aac" | "raw";
    audioBitRate?: number;
    audioCodecOptions?: CodecOptions;
    audioEncoder?: string;
    listEncoders?: boolean;
    listDisplays?: boolean;
    sendCodecMeta?: boolean;
}
export declare class ScrcpyOptions2_0 extends ScrcpyOptionsBase<ScrcpyOptionsInit2_0, ScrcpyOptions1_25> {
    static readonly DEFAULTS: {
        readonly scid: ScrcpyInstanceId;
        readonly videoCodec: "h264";
        readonly videoBitRate: 8000000;
        readonly videoCodecOptions: CodecOptions;
        readonly videoEncoder: "";
        readonly audio: true;
        readonly audioCodec: "opus";
        readonly audioBitRate: 128000;
        readonly audioCodecOptions: CodecOptions;
        readonly audioEncoder: "";
        readonly listEncoders: false;
        readonly listDisplays: false;
        readonly sendCodecMeta: true;
        readonly logLevel: import("./1_18.js").ScrcpyLogLevel1_18.Debug;
        readonly maxSize: 0;
        readonly maxFps: 0;
        readonly lockVideoOrientation: import("./1_18.js").ScrcpyVideoOrientation1_18.Unlocked;
        readonly tunnelForward: false;
        readonly crop: undefined;
        readonly sendFrameMeta: true;
        readonly control: true;
        readonly displayId: 0;
        readonly showTouches: false;
        readonly stayAwake: false;
        readonly powerOffOnClose: false;
        readonly clipboardAutosync: true;
        readonly downsizeOnError: true;
        readonly sendDeviceMeta: true;
        readonly sendDummyByte: true;
        readonly cleanup: true;
        readonly powerOn: true;
    };
    get defaults(): Required<ScrcpyOptionsInit2_0>;
    constructor(init: ScrcpyOptionsInit2_0);
    serialize(): string[];
    setListEncoders(): void;
    setListDisplays(): void;
    parseEncoder(line: string): ScrcpyEncoder | undefined;
    parseDisplay(line: string): ScrcpyDisplay | undefined;
    parseVideoStreamMetadata(stream: ReadableStream<Uint8Array>): ValueOrPromise<ScrcpyVideoStream>;
    parseAudioStreamMetadata(stream: ReadableStream<Uint8Array>): ValueOrPromise<ScrcpyAudioStreamMetadata>;
    serializeInjectTouchControlMessage(message: ScrcpyInjectTouchControlMessage): Uint8Array;
}
//# sourceMappingURL=2_0.d.ts.map