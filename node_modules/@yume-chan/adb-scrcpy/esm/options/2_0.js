import { AdbScrcpyClient, AdbScrcpyExitedError } from "../client.js";
import { AdbScrcpyOptions1_16 } from "./1_16.js";
import { AdbScrcpyOptionsBase } from "./types.js";
export class AdbScrcpyOptions2_0 extends AdbScrcpyOptionsBase {
    static async getEncoders(adb, path, version, options) {
        try {
            // Similar to `AdbScrcpyOptions1_16.getDisplays`,
            // server start process won't complete and `start `will throw
            const client = await AdbScrcpyClient.start(adb, path, version, options);
            // If the server didn't exit, manually stop it and throw an error
            await client.close();
            throw new Error("Unexpected server output");
        }
        catch (e) {
            if (e instanceof AdbScrcpyExitedError) {
                const encoders = [];
                for (const line of e.output) {
                    const encoder = options.parseEncoder(line);
                    if (encoder) {
                        encoders.push(encoder);
                    }
                }
                return encoders;
            }
            throw e;
        }
    }
    async getEncoders(adb, path, version) {
        return AdbScrcpyOptions2_0.getEncoders(adb, path, version, this);
    }
    getDisplays(adb, path, version) {
        return AdbScrcpyOptions1_16.getDisplays(adb, path, version, this);
    }
    createConnection(adb) {
        return AdbScrcpyOptions1_16.createConnection(adb, {
            scid: this.value.scid.value,
            video: true,
            audio: this.value.audio,
            control: this.value.control,
            sendDummyByte: this.value.sendDummyByte,
        }, this.tunnelForwardOverride || this.value.tunnelForward);
    }
}
//# sourceMappingURL=2_0.js.map