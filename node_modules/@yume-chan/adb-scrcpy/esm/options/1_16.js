import { WritableStream } from "@yume-chan/stream-extra";
import { AdbScrcpyClient, AdbScrcpyExitedError } from "../client.js";
import { AdbScrcpyForwardConnection, AdbScrcpyReverseConnection, } from "../connection.js";
import { AdbScrcpyOptionsBase } from "./types.js";
export class AdbScrcpyOptions1_16 extends AdbScrcpyOptionsBase {
    static createConnection(adb, connectionOptions, tunnelForward) {
        if (tunnelForward) {
            return new AdbScrcpyForwardConnection(adb, connectionOptions);
        }
        else {
            return new AdbScrcpyReverseConnection(adb, connectionOptions);
        }
    }
    static async getEncoders(adb, path, version, options) {
        const client = await AdbScrcpyClient.start(adb, path, version, options);
        const encoders = [];
        await client.stdout.pipeTo(new WritableStream({
            write: (line) => {
                const encoder = options.parseEncoder(line);
                if (encoder) {
                    encoders.push(encoder);
                }
            },
        }));
        return encoders;
    }
    static async getDisplays(adb, path, version, options) {
        try {
            // Server will exit before opening connections when an invalid display id was given
            // so `start` will throw an `AdbScrcpyExitedError`
            const client = await AdbScrcpyClient.start(adb, path, version, options);
            // If the server didn't exit, manually stop it and throw an error
            await client.close();
            throw new Error("Unexpected server output");
        }
        catch (e) {
            if (e instanceof AdbScrcpyExitedError) {
                const displays = [];
                for (const line of e.output) {
                    const display = options.parseDisplay(line);
                    if (display) {
                        displays.push(display);
                    }
                }
                return displays;
            }
            throw e;
        }
    }
    getEncoders(adb, path, version) {
        return AdbScrcpyOptions1_16.getEncoders(adb, path, version, this);
    }
    getDisplays(adb, path, version) {
        return AdbScrcpyOptions1_16.getDisplays(adb, path, version, this);
    }
    createConnection(adb) {
        return AdbScrcpyOptions1_16.createConnection(adb, {
            scid: -1,
            video: true,
            audio: false,
            // Old versions always have control stream no matter what the option is
            // Pass `control: false` to `Connection` will disable the control stream
            control: true,
            sendDummyByte: true,
        }, this.tunnelForwardOverride || this.value.tunnelForward);
    }
}
//# sourceMappingURL=1_16.js.map